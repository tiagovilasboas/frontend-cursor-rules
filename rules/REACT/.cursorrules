# ⚛️ React & Next.js Rules
# Based on ponto-pj project patterns

## 🏗️ Project Structure
```
src/
├── components/          # React components
│   ├── common/         # Reusable components
│   ├── features/       # Feature-specific components
│   └── layout/         # Layout components
├── hooks/              # Custom hooks
├── services/           # Business logic services
├── repositories/       # API data access layer
├── stores/            # State management (Zustand)
├── types/             # TypeScript definitions
├── utils/             # Utility functions
└── pages/             # Next.js pages (if using Next.js)
```

## 🎯 Component Patterns
- Use functional components with hooks
- Separate presentational and container components
- Props should be explicit and typed with interfaces
- Use composition over inheritance
- Keep components pure when possible

## 🪝 Custom Hooks
- Create hooks for reusable logic
- Follow naming convention: `use<Feature>`
- Return objects with clear property names
- Handle loading, error, and success states
- Use TypeScript for hook return types

## 📊 State Management
- Use Zustand for global state
- Use React Context for theme/auth state
- Use local state for component-specific data
- Avoid prop drilling with proper state structure
- Implement proper state persistence

## 🔄 Data Fetching
- Use Repository Pattern for API calls
- Create custom hooks for data fetching
- Handle loading and error states properly
- Implement proper caching strategies
- Use React Query for complex data management

## 🎨 Styling
- Use Tailwind CSS for utility-first styling
- Prefer shadcn/ui components when applicable
- Keep styles close to components
- Use CSS modules for complex styling
- Implement responsive design patterns

## 🚀 Performance
- Use React.memo for expensive components
- Implement useMemo for expensive calculations
- Use useCallback for function props
- Implement lazy loading for routes
- Optimize bundle size with code splitting

## 🧪 Testing
- Use React Testing Library for component tests
- Test user interactions, not implementation
- Mock external dependencies properly
- Test custom hooks with renderHook
- Implement integration tests for data flows

## 📱 Next.js Specific (if applicable)
- Use App Router for new projects
- Implement proper SEO with metadata
- Use Server Components when possible
- Implement proper loading and error pages
- Use Next.js Image component for optimization

## 🔧 TypeScript Integration
- Type all props with interfaces
- Use generics for reusable components
- Implement proper error types
- Use discriminated unions for state
- Enable strict mode in tsconfig

## 🎯 Example Patterns

### Component Structure
```typescript
interface ComponentProps {
  data: DataType
  onAction: (id: string) => void
  loading?: boolean
}

export const Component: React.FC<ComponentProps> = ({
  data,
  onAction,
  loading = false
}) => {
  // Component logic
  return (
    <div>
      {/* Component JSX */}
    </div>
  )
}
```

### Custom Hook Pattern
```typescript
interface UseFeatureReturn {
  data: DataType[]
  loading: boolean
  error: string | null
  refetch: () => Promise<void>
}

export const useFeature = (): UseFeatureReturn => {
  // Hook implementation
  return { data, loading, error, refetch }
}
```

### Repository Pattern
```typescript
interface Repository {
  getData(): Promise<DataType[]>
  createData(data: CreateDataType): Promise<DataType>
  updateData(id: string, data: UpdateDataType): Promise<DataType>
  deleteData(id: string): Promise<void>
}
``` 