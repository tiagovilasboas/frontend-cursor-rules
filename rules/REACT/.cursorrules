# âš›ï¸ React & Next.js Rules
# Based on ponto-pj project patterns

## ğŸ—ï¸ Project Structure
```
src/
â”œâ”€â”€ components/          # React components
â”‚   â”œâ”€â”€ common/         # Reusable components
â”‚   â”œâ”€â”€ features/       # Feature-specific components
â”‚   â””â”€â”€ layout/         # Layout components
â”œâ”€â”€ hooks/              # Custom hooks
â”œâ”€â”€ services/           # Business logic services
â”œâ”€â”€ repositories/       # API data access layer
â”œâ”€â”€ stores/            # State management (Zustand)
â”œâ”€â”€ types/             # TypeScript definitions
â”œâ”€â”€ utils/             # Utility functions
â””â”€â”€ pages/             # Next.js pages (if using Next.js)
```

## ğŸ¯ Component Patterns
- Use functional components with hooks
- Separate presentational and container components
- Props should be explicit and typed with interfaces
- Use composition over inheritance
- Keep components pure when possible

## ğŸª Custom Hooks
- Create hooks for reusable logic
- Follow naming convention: `use<Feature>`
- Return objects with clear property names
- Handle loading, error, and success states
- Use TypeScript for hook return types

## ğŸ“Š State Management
- Use Zustand for global state
- Use React Context for theme/auth state
- Use local state for component-specific data
- Avoid prop drilling with proper state structure
- Implement proper state persistence

## ğŸ”„ Data Fetching
- Use Repository Pattern for API calls
- Create custom hooks for data fetching
- Handle loading and error states properly
- Implement proper caching strategies
- Use React Query for complex data management

## ğŸ¨ Styling
- Use Tailwind CSS for utility-first styling
- Prefer shadcn/ui components when applicable
- Keep styles close to components
- Use CSS modules for complex styling
- Implement responsive design patterns

## ğŸš€ Performance
- Use React.memo for expensive components
- Implement useMemo for expensive calculations
- Use useCallback for function props
- Implement lazy loading for routes
- Optimize bundle size with code splitting

## ğŸ§ª Testing
- Use React Testing Library for component tests
- Test user interactions, not implementation
- Mock external dependencies properly
- Test custom hooks with renderHook
- Implement integration tests for data flows

## ğŸ“± Next.js Specific (if applicable)
- Use App Router for new projects
- Implement proper SEO with metadata
- Use Server Components when possible
- Implement proper loading and error pages
- Use Next.js Image component for optimization

## ğŸ”§ TypeScript Integration
- Type all props with interfaces
- Use generics for reusable components
- Implement proper error types
- Use discriminated unions for state
- Enable strict mode in tsconfig

## ğŸ¯ Example Patterns

### Component Structure
```typescript
interface ComponentProps {
  data: DataType
  onAction: (id: string) => void
  loading?: boolean
}

export const Component: React.FC<ComponentProps> = ({
  data,
  onAction,
  loading = false
}) => {
  // Component logic
  return (
    <div>
      {/* Component JSX */}
    </div>
  )
}
```

### Custom Hook Pattern
```typescript
interface UseFeatureReturn {
  data: DataType[]
  loading: boolean
  error: string | null
  refetch: () => Promise<void>
}

export const useFeature = (): UseFeatureReturn => {
  // Hook implementation
  return { data, loading, error, refetch }
}
```

### Repository Pattern
```typescript
interface Repository {
  getData(): Promise<DataType[]>
  createData(data: CreateDataType): Promise<DataType>
  updateData(id: string, data: UpdateDataType): Promise<DataType>
  deleteData(id: string): Promise<void>
}
``` 