# 🟢 Vue & Nuxt.js Rules
# Based on ponto-pj project patterns

## 🏗️ Project Structure
```
src/
├── components/          # Vue components
│   ├── common/         # Reusable components
│   ├── features/       # Feature-specific components
│   └── layout/         # Layout components
├── composables/        # Custom composables (Vue 3)
├── services/           # Business logic services
├── repositories/       # API data access layer
├── stores/            # State management (Pinia)
├── types/             # TypeScript definitions
├── utils/             # Utility functions
└── pages/             # Nuxt.js pages (if using Nuxt)
```

## 🎯 Component Patterns
- Use Composition API with `<script setup>`
- Separate presentational and container components
- Props should be explicit and typed with interfaces
- Use composition over inheritance
- Keep components pure when possible

## 🔄 Composables (Vue 3)
- Create composables for reusable logic
- Follow naming convention: `use<Feature>`
- Return reactive objects with clear property names
- Handle loading, error, and success states
- Use TypeScript for composable return types

## 📊 State Management
- Use Pinia for global state management
- Use provide/inject for component tree state
- Use local state for component-specific data
- Avoid prop drilling with proper state structure
- Implement proper state persistence

## 🔄 Data Fetching
- Use Repository Pattern for API calls
- Create composables for data fetching
- Handle loading and error states properly
- Implement proper caching strategies
- Use Vue Query for complex data management

## 🎨 Styling
- Use Tailwind CSS for utility-first styling
- Prefer Vue UI libraries when applicable
- Keep styles close to components
- Use scoped styles for component-specific CSS
- Implement responsive design patterns

## 🚀 Performance
- Use `v-memo` for expensive components
- Implement computed properties for expensive calculations
- Use `v-once` for static content
- Implement lazy loading for routes
- Optimize bundle size with code splitting

## 🧪 Testing
- Use Vue Test Utils for component tests
- Test user interactions, not implementation
- Mock external dependencies properly
- Test composables with proper setup
- Implement integration tests for data flows

## 📱 Nuxt.js Specific (if applicable)
- Use Nuxt 3 for new projects
- Implement proper SEO with useHead
- Use Server Components when possible
- Implement proper loading and error pages
- Use Nuxt Image component for optimization

## 🔧 TypeScript Integration
- Type all props with interfaces
- Use generics for reusable components
- Implement proper error types
- Use discriminated unions for state
- Enable strict mode in tsconfig

## 🎯 Example Patterns

### Component Structure (Composition API)
```vue
<template>
  <div class="component">
    <h3>{{ title }}</h3>
    <p>{{ description }}</p>
    <button @click="handleAction">Action</button>
  </div>
</template>

<script setup lang="ts">
interface ComponentProps {
  title: string
  description: string
  onAction: (id: string) => void
}

const props = defineProps<ComponentProps>()
const emit = defineEmits<{
  action: [id: string]
}>()

const handleAction = () => {
  emit('action', 'some-id')
}
</script>
```

### Composable Pattern
```typescript
interface UseFeatureReturn {
  data: Ref<DataType[]>
  loading: Ref<boolean>
  error: Ref<string | null>
  refetch: () => Promise<void>
}

export const useFeature = (): UseFeatureReturn => {
  const data = ref<DataType[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const refetch = async () => {
    loading.value = true
    error.value = null
    
    try {
      data.value = await repository.getData()
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
    } finally {
      loading.value = false
    }
  }
  
  return { data, loading, error, refetch }
}
```

### Repository Pattern
```typescript
interface Repository {
  getData(): Promise<DataType[]>
  createData(data: CreateDataType): Promise<DataType>
  updateData(id: string, data: UpdateDataType): Promise<DataType>
  deleteData(id: string): Promise<void>
}

export class ApiRepository implements Repository {
  async getData(): Promise<DataType[]> {
    const response = await fetch('/api/data')
    return response.json()
  }
}
```

### Pinia Store Pattern
```typescript
interface FeatureState {
  data: DataType[]
  loading: boolean
  error: string | null
}

export const useFeatureStore = defineStore('feature', () => {
  const data = ref<DataType[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const fetchData = async () => {
    loading.value = true
    try {
      data.value = await repository.getData()
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
    } finally {
      loading.value = false
    }
  }
  
  return { data, loading, error, fetchData }
})
``` 